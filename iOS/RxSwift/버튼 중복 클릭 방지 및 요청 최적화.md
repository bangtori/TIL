일자 : 2025.03.19.수

**📌 TIL: 버튼 중복 클릭 방지 및 요청 최적화**

## 🛠 문제 상황

프로젝트 진행 중, 게시물 작성과 같은 버튼을 사용자가 여러 번 클릭할 경우, 동일한 저장 요청이 여러 번 발생하는 문제가 발생하였습니다.<br>
이로 인해 서버에 불필요한 요청이 많아지고, 데이터 저장 시 중복이 발생할 가능성이 있었습니다.

## ✅ 해결 방법

RxSwift의 throttle 연산자를 사용하여 버튼 클릭 요청을 일정 시간 동안 제한하였습니다.

```swift
button.rx.tap
    .throttle(.seconds(3), latest: false, scheduler: MainScheduler.instance)
    .subscribe(onNext: {
        // 저장 요청 실행
    })
    .disposed(by: disposeBag)
```

이를 통해 사용자가 여러 번 클릭하더라도 최대 3초에 한 번만 요청이 실행되도록 제어하였습니다.<br>
완전히 중복 요청을 차단하지는 못하지만, 단시간 내 발생하는 과도한 요청을 효과적으로 줄일 수 있었으며, 서버 부하를 완화하는 데 충분한 역할을 하였습니다.

## 🎯 배운 내용 정리

    •	throttle: 일정 시간 동안 첫 번째 이벤트만 허용하고 이후 이벤트는 무시하는 연산자.
    •	latest: false 설정 시 처음 발생한 이벤트만 허용하고, 이후 요청은 지정한 시간 동안 차단됨. (true일 때는 dueTime안에서 벌어진 이벤트들 중에 첫 번째와, 마지막 이벤트를 방출, 기본값 true)
    •	버튼 클릭 이벤트처럼 사용자가 여러 번 클릭할 가능성이 있는 경우, 불필요한 요청을 줄이는 데 효과적임.

완전히 중복 요청을 차단하지는 못하지만, 단시간 내 발생하는 과도한 요청을 효과적으로 줄일 수 있었으며, 서버 부하를 완화하는 데 충분한 역할을 하였습니다.

## 💡 추가로 깨달은 점

과거 닉네임 중복 체크를 구현할 때는 throttle이 아닌 debounce를 사용했던 경험이 있습니다.

닉네임 체크의 경우 텍스트 필드의 값이 변할 때마다 계속해서 체크 요청을 보내면 너무 많은 요청을 보내야하기에,<br>
사용자 입력이 일정시간동안 멈출 경우 입력을 완료했다고 간주하고 요청을 보내기로 했습니다.

#### debounce(x)

timer로 지정된 x동안 새로운 이벤트가 발생하면 이전이벤트는 무시되고 Timer가 초기화된다.
Debounce는 반대로 x동안 무시하다가 마지막으로 발생한 이벤트를 방출한다.

즉 두 연산자는 동일하게 중복 요청을 막을 수 있지만 동작 방식의 차이를 가지고 있었습니다.

- throttle: 일정 시간 내 최초 요청을 허용하고 이후 요청을 제한 → 버튼 클릭 방지에 유용
- debounce: 입력이 멈춘 후 일정 시간이 지나면 실행 → 사용자 입력 필드(닉네임 중복 체크) 등에 적합

이 두 연산자의 차이를 이해하고 적절한 상황에 적용하면, 사용자 경험을 유지하면서도 불필요한 API 호출을 최소화할 수 있다는 점을 다시 한번 깨달았습니다.

## 📌 마무리

이 경험을 통해 클라이언트 측에서 불필요한 요청을 최소화하는 것이 서버 성능 최적화에 중요하다는 점을 다시 한번 깨달았습니다.
• 버튼과 같은 이벤트는 throttle을 사용해 중복 요청을 방지하고,
• 입력 필드와 같은 경우는 debounce를 사용해 최적의 시점에서 요청을 보낼 수 있도록 조절하는 것이 효과적입니다.

앞으로도 사용자 경험을 해치지 않으면서도 효율적으로 API 요청을 관리하는 전략을 고민하며 개발을 진행해야겠습니다.
